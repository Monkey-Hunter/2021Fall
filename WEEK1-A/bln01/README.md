# 자료구조

값의 `삽입`, `삭제`, `탐색` 연산을 빠르게 하기 위해 상황에 맞는 효율적인 자료구조(Data Structure)를 사용한다.

<hr/>

## 리스트

리스트는 선형(순서가 있음)으로 값을 저장하는 자료구조로, `배열(Array)`, `연결 리스트(linked list)`로 나눌 수 있다.

배열은 메모리 상 연속된 공간을 차지하며, 이 특성 때문에 `index`를 통해 배열의 원소에 `O(1)` 만에 접근(탐색 연산이라고 할 수 있겠다.)이 가능하나(`random access`), 자유로운 삽입 및 삭제가 불가능하다.

연결리스트는 배열과 다르게 값 하나하나가 노드를 이루며, 각각의 노드는 다음 값을 가지는 노드를 가리킨다. (다음 노드가 존재하지 않으면 null 포인터가 된다.) (C++의 vector 등)

즉, 연결리스트의 각 노드는 자신의 값과 다음 노드를 가리키는 포인터, 두개의 값을 가진다. 또한, 이 중 첫 번째 값을 가진 노드를 head node로 가리킨다. (값의 개수 등도 따로 저장해두기도 함.)

연속된 메모리 공간을 가지는 배열과 달리 각각의 노드가 다음 노드를 가리키는 형태를 취하므로 `삽입`과 `삭제`는 자유로우나, 삽입, 삭제 연산과 n번째 노드의 값을 참조하는 것(탐색) 모두 `O(N)`의 시간이 걸린다.

마지막 노드가 다시 첫 번째 노드를 가리키는 순환 구조를 갖는 원형 연결 리스트(circular linked list), 각 노드가 자신의 이전 노드 또한 가리키는 이중 연결 리스트(doubly linked list) 등의 변형도 존재한다. (사실 구현하기 나름이니까)

각각의 장단점이 있으므로, 상황에 따라 맞는 자료구조를 사용한다. 배열이 적합할 때는 랜덤 액세스가 필요할 상황이고, 연결 리스트가 적합한 상황은 삽입, 삭제가 많이 이루어지는 상황이다.

## 스택 (Stack)

`LIFO(Last In First Out)` 자료구조, 즉 가장 마지막에 들어간 원소가 가장 먼저 나온다.

편하게 책 더미를 생각해보면 된다. 책을 쌓아두면, 위에서 부터 책을 꺼낸다고 할 때, 마지막으로 쌓은 책을 가장 먼저 꺼낼 수 있다. 보통 한 구멍만 뚫려있는 통의 형태로 시각화한다.

스택은 맨 위에 새 값을 쌓는 삽입 연산과, 맨위의 값을 빼는 삭제 연산을 하며, 맨 위의 값만을 알 수 있다.(탐색)

여기서 보통 삽입을 `push`, 삭제를 `pop`, 맨 위의 값을 보는 연산을 `top` 연산이라고 부른다. (스택에 원소가 없을 때 pop, top 연산시 underflow가 발생한다.)

특정 구간에서만 삽입 삭제가 이루어지므로 `연결 리스트`로 구현하며, 맨 위의 데이터만 참조하고, 맨위의 데이터에만 연산을 수행하므로 모든 연산이 `O(1)`의 시간 복잡도를 가진다.

LIFO 구조가 재귀적인 구조와 유사성을 가지므로 프로그램 상에서 지역 변수와 매개 변수를 저장할 때 스택 메모리를 사용하며 함수의 재귀적 호출도 스택을 사용한다.

DFS를 재귀 호출 없이 구현할 때 사용할 수 있다.

## 큐 (Queue)

큐는 스택과 반대로 `FIFO(First In First Out)` 형태의 자료구조, 즉 들어온 순서대로 나오는 형태의 자료구조이다.

스택처럼 가장 끝부분에서만 삽입 및 삭제 연산이 이루어지며 중간의 값은 알 필요가 없다. 그러나 스택이 삽입과 삭제를 같은 쪽에서 하는 것과 달리, 큐는 서로 다른 쪽에서 이루어진다.

대기 줄을 서는 것과 비슷하며, 게임 큐를 잡는 것의 어원이라고도 할 수 있겠다. 보통 양쪽에 입구가 있는 통으로 시각화한다.

보통 삽입이 이루어지는 입구를 `rear`, 삭제가 이루어지는 출구를 `front`라고 하며, 참조할 수 있는 값도 일반적으로 `front`이다.

큐도 스택과 마찬가지로 `연결리스트`로 구현하며, 삽입, 삭제 연산이 `O(1)`이다. 또한, 큐도 `push`, `pop`이라는 단어를 사용한다.

무언가 순서대로 처리할 때 많이 사용하고, BFS에서도 사용한다.

## 우선순위 큐 (Priority Queue)

우선순위 큐는, 이름에 큐가 붙어있듯이 `push`, `top`, `pop` 연산을 수행한다. 대신, `top`, `pop`의 대상이 되는 원소는 `가장 우선순위가 높은 원소`이다. 

보통 `힙(heap)`으로 구현하는데, 힙은 `완전 이진 트리(complete binary tree)`로, 완전 이진 트리를 이루는 위치에 삽입이 되고, 삭제는 `root`에서 이루어진다. 힙은 parent 노드가 child 노드보다 높은 우선순위를 가지는 재귀구조이다.

값 삽입 후에는 트리의 parent, child node를 각각 비교하여 위치를 바꿔준다. 삭제 후에는 완전 이진 트리 구조를 해치지 않는, 마지막 leaf 노드 값을 root에 넣고, 상기한 연산을 통해 우선순위를 유지한다. 이 연산은 `O(logN)`을 가지므로, 우선순위 큐(힙)의 삽입, 삭제 계산 복잡도는 `O(logN)`이다. 

트리의 깊이 특성 상, 탐색 연산 또한 `O(logN)`

가장 많이 쓰이는 형태는 값이 클수록 우선순위가 높은 `max heap`, 값이 작을수록 우선순위가 높은 `min heap`이다. 힙은 배열을 이용하면 인덱스 구조덕분에 쉽게 구현할 수 있다. **루트를 1번 인덱스로** 구현 시, i번째 노드의 부모 인덱스는 `i/2`, 왼쪽 자식은 `i*2`, 오른쪽 자식은 `i*2+1`이다. (자리도 바꾸기 쉬움)

힙을 이용하면 정렬도 손쉽게 할 수 있는데, N개의 원소를 삽입했다가 삭제하면 되므로, O(logN) 연산을 2N번 시행하므로, `O(NlogN)`의 시간복잡도를 가진다.

자료구조 상 정렬이 되어있으므로, 다익스트라 알고리즘이나 크루스칼 알고리즘에서 애용한다.

## Reference

[리스트](https://blog.naver.com/kks227/220781402507)
[스택](https://blog.naver.com/kks227/220781557098)
[큐](https://blog.naver.com/kks227/220781851401)
[우선순위 큐](https://blog.naver.com/kks227/220791188929)
전공 수업 및 여러 블로그 글들, 뇌피셜
